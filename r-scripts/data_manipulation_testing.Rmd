---
title: "data_manipulation_testing"
author: "Peter Silverstein"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(httr)
library(stringr)
library(purrr)
library(sf)
library(jsonlite)
library(geojsonsf)
library(lwgeom)
library(units)
library(zoo)
library(lme4)
library(tmap)
```

```{r}
# Getting MTA Bus Speed Data via API

# 2015-2019: https://data.ny.gov/Transportation/MTA-Bus-Speeds-2015-2019/cudb-vcni/about_data
url <- "https://data.ny.gov/resource/cudb-vcni.json?$limit=100000"
res <- GET(url)
if (status_code(res) != 200) {
  stop("Request failed with status: ", status_code(res))
}
df_15_19 <- tibble(fromJSON(content(res, "text"), flatten = TRUE)) %>%
  mutate(date = str_split_fixed(month, "T", 2)[, 1]) %>%
  select(!month) %>%
  mutate(
    day_type = as.numeric(day_type),
    total_operating_time = as.numeric(total_operating_time),
    total_mileage = as.numeric(total_mileage),
    average_speed = as.numeric(average_speed),
    date = as.Date(date)
  )

# 2020-2024: https://data.ny.gov/Transportation/MTA-Bus-Speeds-2020-2024/6ksi-7cxr/about_data
url <- "https://data.ny.gov/resource/6ksi-7cxr.json?$limit=100000"
res <- GET(url)
if (status_code(res) != 200) {
  stop("Request failed with status: ", status_code(res))
}
df_20_24 <- tibble(fromJSON(content(res, "text"), flatten = TRUE)) %>%
  mutate(date = str_split_fixed(month, "T", 2)[, 1]) %>%
  select(!month) %>%
  relocate(total_operating_time, .before = total_mileage) %>%
  mutate(
    day_type = as.numeric(day_type),
    total_operating_time = as.numeric(total_operating_time),
    total_mileage = as.numeric(total_mileage),
    average_speed = as.numeric(average_speed),
    date = as.Date(date)
  )

# 2025: https://data.ny.gov/Transportation/MTA-Bus-Speeds-Beginning-2025/4u4b-jge6/about_data 
url <- "https://data.ny.gov/resource/4u4b-jge6.json?$limit=100000"
res <- GET(url)
if (status_code(res) != 200) {
  stop("Request failed with status: ", status_code(res))
}
df_25 <- tibble(fromJSON(content(res, "text"), flatten = TRUE)) %>%
  mutate(date = str_split_fixed(month, "T", 2)[, 1]) %>%
  select(!month) %>%
  mutate(
    day_type = as.numeric(day_type),
    total_operating_time = as.numeric(total_operating_time),
    total_mileage = as.numeric(total_mileage),
    average_speed = as.numeric(average_speed),
    date = as.Date(date)
  )

df_combined <- rbind(df_15_19, df_20_24, df_25) %>%
  mutate(
    total_mileage = round(total_mileage, 1),
    average_speed = round(average_speed, 2)
    ) %>%
  mutate(
    year = str_split_fixed(date, "-", 3)[, 1],
    month = str_split_fixed(date, "-", 3)[, 2]
  ) %>%
  select(!date)
```

```{r}
df_speeds <- df_combined %>%
  mutate(
    borough = as.factor(borough),
    trip_type = as.factor(trip_type),
    route_id = as.factor(route_id),
    period = as.factor(period),
    date = as.yearmon(paste(year, month), "%Y %m"),
    year = as.factor(year),
    month = as.factor(month),
  ) %>%
  rename(Route_ID = route_id)
summary(df_speeds)
```

```{r}
# Loading Bus Lanes - Local Streets: https://data.cityofnewyork.us/Transportation/Bus-Lanes-Local-Streets/ycrg-ses3/about_data 
url <- "https://data.cityofnewyork.us/resource/ycrg-ses3.json?$limit=5000"
res <- GET(url)
if (status_code(res) != 200) {
  stop("Request failed with status: ", status_code(res))
}
local_streets <- fromJSON(content(res, "text"), flatten = TRUE)

# Create GeoJSON strings for each row from the_geom.type and the_geom.coordinates
geojson_strings <- mapply(function(t, coords) {
  toJSON(list(type = t, coordinates = coords), auto_unbox = TRUE)
}, local_streets$the_geom.type, local_streets$the_geom.coordinates)

# Convert each GeoJSON geometry string to sf geometry objects
geoms_sf <- geojsonsf::geojson_sf(paste0('{"type":"Feature","geometry":', geojson_strings, '}'))

# Combine geometries with attributes (dropping original the_geom columns)
bus_lanes_sf <- st_sf(local_streets[, !(names(local_streets) %in% c("the_geom.type", "the_geom.coordinates", "the_geom"))], geometry = geoms_sf$geometry)

# Coordinate reference system likely WGS84
st_crs(bus_lanes_sf) <- 4326

bus_lanes_sf <- bus_lanes_sf %>%
  distinct(segmentid, .keep_all = TRUE) %>%
  filter(
    lane_type1 %in% c("Bus Lane", "Busway", "SBS Bus Lane"),  # True lanes only
    !str_detect(hours, "queue|signal|stop"),  # No queue jumps/stop bays
    days != "None"  # 24/7 or peak lanes only
  )
```

```{r}
# Loading Bus Route Geometries: https://data.ny.gov/Transportation/MTA-Bus-Routes/bzwk-3hb4/explore/query/SELECT%0A%20%20%60valid_from%60%2C%0A%20%20%60valid_to%60%2C%0A%20%20%60route_id%60%2C%0A%20%20%60route_short_name%60%2C%0A%20%20%60route_long_name%60%2C%0A%20%20%60route_description%60%2C%0A%20%20%60trip_type%60%2C%0A%20%20%60route_type%60%2C%0A%20%20%60bundle%60%2C%0A%20%20%60route_color%60%2C%0A%20%20%60direction_id%60%2C%0A%20%20%60direction%60%2C%0A%20%20%60shape_id%60%2C%0A%20%20%60vertices%60%2C%0A%20%20%60shape_length%60%2C%0A%20%20%60min_longitude%60%2C%0A%20%20%60min_latitude%60%2C%0A%20%20%60max_longitude%60%2C%0A%20%20%60max_latitude%60%2C%0A%20%20%60geometry%60%0AWHERE%20%60valid_to%60%20%3E%20%222025-01-01T11%3A13%3A22%22%20%3A%3A%20floating_timestamp%0AORDER%20BY%0A%20%20%60valid_from%60%20DESC%20NULL%20LAST%2C%0A%20%20%60route_id%60%20ASC%20NULL%20LAST%2C%0A%20%20%60valid_to%60%20DESC%20NULL%20LAST/page/filter

route_shapes <- read_csv("../data/MTA_Bus_Routes.csv")
colnames(route_shapes) <- gsub(" ", "_", colnames(route_shapes))

route_shapes <- route_shapes %>%
  filter(Route_Type %in% c("Local", "Express", "SBS")) %>%
  filter(Route_ID %in% unique(df_combined$route_id))

route_shapes$Geometry <- st_as_sfc(route_shapes$Geometry, crs=4326)
invalid = !st_is_valid(route_shapes$Geometry)
if (any(invalid)) {
  route_shapes$Geometry[invalid] <- st_make_valid(route_shapes$Geometry[invalid])
}
route_shapes_sf <- st_sf(route_shapes)
```

```{r}
# Keep longest shape per Route_ID + direction_id only
route_shapes_dir_sf <- route_shapes_sf %>%
  filter(Route_Type %in% c("Local", "Express", "SBS")) %>%
  filter(Route_ID %in% unique(df_combined$route_id)) %>%
  st_transform(2263) %>%
  mutate(Geometry = st_make_valid(Geometry)) %>%
  # REMOVE slice_max - keep ALL shapes per direction
  group_by(Route_ID, Direction_ID) %>%
  summarise(Geometry = st_union(Geometry), .groups = "drop") %>%  # Unions ALL shapes
  mutate(
    total_length_ft = st_length(Geometry),
    Geometry = st_simplify(Geometry, dTolerance = set_units(10, "ft"))
  )
```

```{r}
bus_lanes_proj <- st_transform(bus_lanes_sf, 2263)

# Buffer each direction separately
route_shapes_dir_buffered <- st_buffer(route_shapes_dir_sf, dist = set_units(100, "ft"))

# Intersect with directional buffers (adds direction_id to intersections)
bus_lane_intersections_dir <- st_intersection(bus_lanes_proj, route_shapes_dir_buffered) %>%
  select(any_of(colnames(bus_lanes_proj)), Route_ID, Direction_ID) %>%
  filter(st_geometry_type(.) %in% c("LINESTRING", "MULTILINESTRING")) %>%
  mutate(length_ft = st_length(.)) %>%
  filter(length_ft >= set_units(25, "ft"))

```

```{r}
# Testing: it's not perfect--perpendicular intersection is a problem, but not a huge one, I don't think
route <- "QM1"

filtered_intersections_fortest <- bus_lane_intersections_dir %>%
  filter(Route_ID == route)

bus_routes_proj_fortest <- route_shapes_dir_buffered %>%
  filter(Route_ID == route)

tmap_mode("view")  # Set tmap to interactive mode

map_fortest <- tm_shape(filtered_intersections_fortest) + 
  tm_lines(col = "red", lwd = 2, alpha = 0.7, legend.show = FALSE) +
  tm_shape(bus_routes_proj_fortest) + 
  tm_lines(col = "blue", lwd = 2, alpha = 0.7, legend.show = FALSE) +
  tm_layout(title = paste("Bus Route", route, "with Bus Lane Intersections"),
            legend.position = c("left", "bottom"))

# Print the interactive map
map_fortest
```


```{r}
# Cleaning up directional intersections
intersection_final_dir <- bus_lane_intersections_dir %>%
  select(boro, hours, days, lane_type1, open_dates, Route_ID, Direction_ID, length_ft, segmentid) %>%
  mutate(open_date_str = sapply(str_split(open_dates, ","), `[`, 1)) %>%
  mutate(open_date = parse_date_time(open_date_str, orders = c("%m/%d/%Y", "%m/%d/%y"))) %>%
  filter(!is.na(open_date)) %>%
  mutate(open_date = case_when(open_date == as.Date("2063-05-20") ~ as.Date("1963-05-20"), TRUE ~ open_date)) %>%
  st_drop_geometry() %>%
  # DEDUPE HERE by segmentid + open_date
  distinct(Route_ID, Direction_ID, segmentid, open_date, .keep_all = TRUE) %>%
  group_by(Route_ID, Direction_ID, open_date) %>%
  summarize(tot_buslane_ft = sum(length_ft), .groups = "drop") %>%
  mutate(tot_buslane_ft = as.numeric(tot_buslane_ft))
```

```{r}
# Joining intersection_final to df_speeds
df_speeds$date <- as.Date(df_speeds$date)
intersection_final_dir$open_date <- as.Date(intersection_final_dir$open_date)

# Directional route lengths
route_length_dir <- route_shapes_dir_sf %>%
  st_drop_geometry() %>%
  mutate(route_length_miles = as.numeric(total_length_ft / 5280))

# before the df_complete pipeline:
df_speeds <- df_speeds %>% mutate(Route_ID = as.character(Route_ID))
intersection_final_dir <- intersection_final_dir %>% mutate(Route_ID = as.character(Route_ID))
route_length_dir <- route_length_dir %>% mutate(Route_ID = as.character(Route_ID))

df_complete <- df_speeds %>%
  left_join(intersection_final_dir %>% 
              filter(open_date <= max(df_speeds$date, na.rm = TRUE)),
            by = "Route_ID", relationship = "many-to-many") %>%
  filter(date >= open_date | is.na(open_date)) %>%
  # Aggregate at ROUTE level (ignores direction issues)
  group_by(Route_ID, date, day_type, period) %>%
  summarise(bus_lane_ft = sum(tot_buslane_ft, na.rm = TRUE), .groups = "drop") %>%
  # Average route length ACROSS all directions per route
  left_join(route_length_dir %>% 
              group_by(Route_ID) %>%
              summarise(route_length_miles = sum(route_length_miles, na.rm = TRUE), 
                       .groups = "drop"),
            by = "Route_ID") %>%
  mutate(
    bus_lane_ft = coalesce(bus_lane_ft, 0),
    lane_miles = bus_lane_ft / 5280,
    lane_perc = case_when(
      is.na(route_length_miles) | route_length_miles <= 0 ~ 0,
      TRUE ~ pmin(pmax(lane_miles / route_length_miles * 100, 0), 100)
    )
  ) %>%
  right_join(df_speeds %>% 
               select(Route_ID, date, day_type, period, average_speed, 
                      borough, trip_type, year, month),
             by = c("Route_ID", "date", "day_type", "period"))


```

```{r}
# Stan-ifying data (turning everything to a number)
## Desired Final Columns
  ### Route_ID -- to factor
  ### day_type -- 1 == Weekday, 2 == Weekend
  ### period -- to factor, 1 == peak, 0 == off-peak
  ### bus_lane_ft -- numeric
  ### borough -- to factor, 1 = M, 2 = BX, 3 = BK, 4 = Q, 5 = S
  ### trip_type -- to factor, EXP = 1, LCL/LTD = 2, SBS = 3
  ### average_speed -- outcome! in mph
  ### year -- MLM level
  ### month -- MLM level
  ### lane_perc -- Treatment
  ### lane_miles -- Treatment (alternative)

df_modeling <- df_complete %>%
  select(
    Route_ID,
    day_type,
    period,
    bus_lane_ft,
    borough,
    trip_type,
    average_speed,
    year,
    month,
    lane_perc,
    lane_miles,
    route_length_miles
  ) %>%
  mutate(
    route_num = as.integer(factor(Route_ID)),
    period = case_when(
      period == 'Peak' ~ 1,
      period == 'Off-Peak' ~ 0,
      TRUE ~ NaN
      ),
    borough = case_when(
      borough == 'Manhattan' ~ 1,
      borough == 'Bronx' ~ 2,
      borough == 'Brooklyn' ~ 3,
      borough == 'Queens' ~ 4,
      borough == 'Staten Island' ~ 5,
      TRUE ~ NaN
      ),
    trip_type = case_when(
      trip_type == 'EXP' ~ 1,
      trip_type == 'LCL/LTD' ~ 2,
      trip_type == 'SBS' ~ 3,
      TRUE ~ NaN
      ),
    day_type = day_type - 1
  ) %>%
  rename(
    'peak' = 'period',
    'weekend' = 'day_type'
  ) %>%
  filter(!is.na(route_length_miles)) %>%
  mutate(lane_perc = case_when(
    lane_perc > 100 ~ 100,
    TRUE ~ lane_perc
  ))

summary(df_modeling)
```

```{r}
# Saving file
write_csv(df_modeling, "../data/final_modeling_data.csv")
```

```{r}
# Testing: it's not perfect--perpendicular intersection is a problem, but not a huge one, I don't think
route <- "QM1"

filtered_intersections_fortest <- bus_lane_intersections_dir %>%
  filter(Route_ID == route)

bus_routes_proj_fortest <- route_shapes_dir_buffered %>%
  filter(Route_ID == route)

tmap_mode("view")  # Set tmap to interactive mode

map_fortest <- tm_shape(bus_routes_proj_fortest) + 
  tm_lines(col = "blue", lwd = 2, alpha = 0.7, legend.show = FALSE) +
  tm_layout(title = paste("Proposed Queens Blvd. Corridor: QM1 Example"),
            legend.position = c("left", "bottom"))

# Print the interactive map
map_fortest
```
